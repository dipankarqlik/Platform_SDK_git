"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * @jest-environment node
 */
const enigma_js_1 = __importDefault(require("enigma.js"));
const _12_612_0_json_1 = __importDefault(require("enigma.js/schemas/12.612.0.json"));
const ws_1 = __importDefault(require("ws"));
const process_1 = __importDefault(require("process"));
const path_1 = __importDefault(require("path"));
const dotenv_1 = __importDefault(require("dotenv"));
const fs_1 = __importDefault(require("fs"));
const qlik_1 = require("../../src/qlik");
describe('APIKey', () => {
    beforeAll(() => {
        const envPath = path_1.default.join(__dirname, '.env');
        if (fs_1.default.existsSync(envPath)) {
            dotenv_1.default.config({ path: envPath });
        }
    });
    it('should be able to make a get request', async () => {
        expect(process_1.default.env.QCS_SERVER).toBeDefined();
        expect(process_1.default.env.QCS_API_KEY).toBeDefined();
        expect(process_1.default.env.QCS_API_KEY.length).toBeGreaterThan(0);
        const auth = new qlik_1.Auth({
            authType: qlik_1.AuthType.APIKey,
            host: process_1.default.env.QCS_SERVER,
            apiKey: process_1.default.env.QCS_API_KEY,
        });
        const res = await auth.rest('/users/me');
        expect(res.status).toBe(200);
        const data = await res.json();
        expect('name' in data).toBeTruthy();
    });
    it('should be able to make a get, post, patch and delete request', async () => {
        expect(process_1.default.env.QCS_SERVER).toBeDefined();
        expect(process_1.default.env.QCS_API_KEY).toBeDefined();
        expect(process_1.default.env.QCS_API_KEY.length).toBeGreaterThan(0);
        // post empty: {} to create an empty app
        const auth = new qlik_1.Auth({
            authType: qlik_1.AuthType.APIKey,
            host: process_1.default.env.QCS_SERVER,
            apiKey: process_1.default.env.QCS_API_KEY,
        });
        const res = await auth.rest('/users/me');
        expect(res.status).toBe(200);
        const data = await res.json();
        expect('name' in data).toBeTruthy();
    });
    it('should be able to connect to the engine using enigma.js', async () => {
        const apiKey = process_1.default.env.QCS_API_KEY;
        const auth = new qlik_1.Auth({
            authType: qlik_1.AuthType.APIKey,
            host: process_1.default.env.QCS_SERVER,
            apiKey,
        });
        // create app
        const createAppRes = await auth.rest('/apps', { method: 'post' });
        expect(createAppRes.status).toBe(200);
        const data = await createAppRes.json();
        const appId = data.attributes.id;
        // connect to engine
        const wssUrl = await auth.generateWebsocketUrl(appId);
        const session = enigma_js_1.default.create({
            schema: _12_612_0_json_1.default,
            createSocket: () => new ws_1.default(wssUrl, {
                headers: { Authorization: `Bearer ${apiKey}` },
            }),
        });
        // bind traffic events to log what is sent and received on the socket:
        session.on('traffic:sent', jest.fn);
        session.on('traffic:received', jest.fn);
        // open the socket and eventually receive the QIX global API, and then close
        // the session:
        const finished = jest.fn(() => true);
        try {
            await session.open();
            await session.close();
            finished();
        }
        catch (err) {
            // TODO error handling?
        }
        expect(finished).toHaveReturned();
        // delete app
        const deleteRes = await auth.rest(`/apps/${appId}`, {
            method: 'delete',
        });
        expect(deleteRes.status).toBe(200);
    }, 30000);
});
//# sourceMappingURL=api-key.test.js.map