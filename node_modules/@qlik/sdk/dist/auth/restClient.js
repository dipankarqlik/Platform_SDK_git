"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const cross_fetch_1 = __importDefault(require("cross-fetch"));
const errors_1 = require("../errors");
const types_1 = require("../types/types");
const utils_1 = require("../utils/utils");
/**
 * @remarks
 * RestClient is used to make http requests
 *
 * @param config - required configuration
 *
 * @returns an instance of the RestClient class.
 */
class RestClient {
    restClientInstance;
    constructor(config) {
        this.restClientInstance = async (resource, init) => {
            const urlString = (0, utils_1.sanitizeUrl)(`${config.host}/api/v1/${resource}`).href;
            let headers = {};
            if (config.authType === types_1.AuthType.APIKey) {
                headers = { Authorization: `Bearer ${config.apiKey}` };
            }
            else if (config.authType === types_1.AuthType.WebIntegration) {
                let { csrfToken } = config;
                const initMethod = init?.method ?? 'get';
                if (!csrfToken && initMethod.toUpperCase() !== 'GET') {
                    const csrf = await this.restClientInstance('/csrf-token');
                    csrfToken = csrf.headers['qlik-csrf-token'];
                }
                headers = {
                    'qlik-web-integration-id': config.webIntegrationId,
                };
                if (csrfToken) {
                    headers['qlik-csrf-token'] = csrfToken;
                }
            }
            const initUpdatedHeaders = {
                ...init,
                headers: {
                    'content-type': 'application/json',
                    ...headers,
                },
            };
            let response;
            try {
                response = await (0, cross_fetch_1.default)(urlString, {
                    ...initUpdatedHeaders,
                    credentials: 'include',
                });
            }
            catch (error) {
                throw new errors_1.ConnectionError(`${errors_1.ConnectionErrorMsg.NO_RESPONSE}: ${config.host}`);
            }
            if (response.ok) {
                return response;
            }
            if (response.status === 401) {
                if (config.authType === types_1.AuthType.APIKey) {
                    throw new errors_1.AuthenticationError(errors_1.AuthenticationErrorMsg.FAILED_AUTH_API_KEY);
                }
            }
            if (response.status === 404) {
                throw new Error(response.statusText);
            }
            throw new Error(response.statusText);
        };
    }
}
exports.default = RestClient;
//# sourceMappingURL=restClient.js.map