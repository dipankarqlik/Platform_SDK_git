"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
/* eslint-disable no-new */
const cross_fetch_1 = __importDefault(require("cross-fetch"));
const qlik_1 = require("../qlik");
const errors_1 = require("../errors");
const { Response } = jest.requireActual('cross-fetch');
jest.mock('cross-fetch', () => jest.fn());
describe('Validate Auth Config', () => {
    beforeEach(() => {
        jest.clearAllMocks();
    });
    it('should not be possible to create a config without authType', () => {
        const t = () => {
            const config = { host: 'http://mock-host.com', authType: null };
            new qlik_1.Auth(config);
        };
        expect(t).toThrowError(new errors_1.CustomError('Unsupported authType: null'));
    });
    it('should not be possible to create a config with invalid authType', () => {
        const t = () => {
            // @ts-ignore authType is the wrong type on purpose for the test
            const config = { host: 'http://mock-host.com', authType: 'abc' };
            new qlik_1.Auth(config);
        };
        expect(t).toThrowError(new errors_1.CustomError('Unsupported authType: abc'));
    });
    it('should not be possible to create a config with empty host', () => {
        const t = () => {
            const config = {
                host: '',
                authType: qlik_1.AuthType.APIKey,
                apiKey: '',
            };
            new qlik_1.Auth(config);
        };
        expect(t).toThrowError(new errors_1.CustomError(errors_1.CustomErrorMsg.EMPTY_HOST));
    });
    describe('WebIntegration', () => {
        it('should throw error on missing keys', () => {
            const t = () => {
                const config = {
                    host: 'http://mock-host.com',
                    authType: qlik_1.AuthType.WebIntegration,
                };
                new qlik_1.Auth(config);
            };
            expect(t).toThrowError(new errors_1.CustomError('Missing config property: webIntegrationId'));
        });
        it('should throw error on missing webIntegrationId', () => {
            const t = () => {
                const config = {
                    host: 'http://mock-host.com',
                    authType: qlik_1.AuthType.WebIntegration,
                    autoRedirect: false,
                };
                new qlik_1.Auth(config);
            };
            expect(t).toThrowError(new errors_1.CustomError('Missing config property: webIntegrationId'));
        });
        it('should not throw error on missing autoRedirect', () => {
            const t = jest.fn(() => {
                const config = {
                    host: 'http://mock-host.com',
                    authType: qlik_1.AuthType.WebIntegration,
                    webIntegrationId: '',
                };
                new qlik_1.Auth(config);
            });
            t();
            expect(t).toHaveReturned();
        });
        it('should throw on unsupported property', () => {
            const t = () => {
                const config = {
                    host: 'http://mock-host.com',
                    authType: qlik_1.AuthType.WebIntegration,
                    webIntegrationId: '',
                    autoRedirect: true,
                    apiKey: '',
                };
                new qlik_1.Auth(config);
            };
            expect(t).toThrowError(new errors_1.CustomError('Unsupported property for authType WebIntegration'));
        });
        it('should be possible to create a WebIntegration Config', () => {
            const t = jest.fn(() => {
                const config = {
                    host: 'http://mock-host.com',
                    authType: qlik_1.AuthType.WebIntegration,
                    webIntegrationId: '',
                    autoRedirect: true,
                };
                new qlik_1.Auth(config);
            });
            t();
            expect(t).toHaveReturned();
        });
    });
    describe('APIKey', () => {
        it('should throw error on missing apiKey', () => {
            const t = () => {
                const config = {
                    host: 'http://mock-host.com',
                    authType: qlik_1.AuthType.APIKey,
                };
                new qlik_1.Auth(config);
            };
            expect(t).toThrowError(new errors_1.CustomError('Missing config property: apiKey'));
        });
        it('should throw on unsupported property', () => {
            const t = () => {
                const config = {
                    host: 'http://mock-host.com',
                    authType: qlik_1.AuthType.APIKey,
                    apiKey: '',
                    autoRedirect: true,
                };
                new qlik_1.Auth(config);
            };
            expect(t).toThrowError(new errors_1.CustomError('Unsupported property for authType APIKey'));
        });
        it('should be possible to create an APIKey Config', () => {
            const t = jest.fn(() => {
                const config = {
                    host: 'http://mock-host.com',
                    authType: qlik_1.AuthType.APIKey,
                    apiKey: '',
                };
                new qlik_1.Auth(config);
            });
            t();
            expect(t).toHaveReturned();
        });
        it('websocket url', async () => {
            jest.mocked(cross_fetch_1.default).mockResolvedValue(new Response(null, {
                status: 200,
                headers: { 'qlik-csrf-token': 'mock-csrf-token' },
            }));
            const config = {
                host: 'http://mock-host',
                authType: qlik_1.AuthType.APIKey,
                apiKey: '',
            };
            const auth = new qlik_1.Auth(config);
            const mockAppId = 'mockAppId';
            expect(await auth.generateWebsocketUrl(mockAppId)).toEqual('ws://mock-host/app/mockAppId');
            const mockHostSecure = 'https://mock-host';
            auth.config.host = mockHostSecure;
            expect(await auth.generateWebsocketUrl(mockAppId)).toEqual('wss://mock-host/app/mockAppId');
        });
    });
});
describe('WebIntegration', () => {
    describe('should throw error on call of webintegration specific function with other auth type', () => {
        it('isAuthenticated', () => {
            expect.assertions(1);
            expect(() => {
                const config = {
                    host: 'http://mock-host.com',
                    authType: qlik_1.AuthType.APIKey,
                    apiKey: '',
                };
                const auth = new qlik_1.Auth(config);
                return auth.isAuthenticated();
            }).rejects.toThrowError(new errors_1.CustomError('Only supported for AuthType.WebIntegration'));
        });
        it('authenticate', () => {
            const t = () => {
                const config = {
                    host: 'http://mock-host.com',
                    authType: qlik_1.AuthType.APIKey,
                    apiKey: '',
                };
                const auth = new qlik_1.Auth(config);
                auth.authenticate();
            };
            expect(t).toThrowError(new errors_1.CustomError('Only supported for AuthType.WebIntegration'));
        });
        it('deAuthenticate', () => {
            const t = () => {
                const config = {
                    host: 'http://mock-host.com',
                    authType: qlik_1.AuthType.APIKey,
                    apiKey: '',
                };
                const auth = new qlik_1.Auth(config);
                auth.deAuthenticate();
            };
            expect(t).toThrowError(new errors_1.CustomError('Only supported for AuthType.WebIntegration'));
        });
    });
});
//# sourceMappingURL=qlik.test.js.map